IO/Stream«"# Streams API

The Streams API allows JavaScript to programmatically access streams of data received over the network and process them as desired by the developer."¸ import«Control/Async¸ Data/Buffer¸ Web/Base¸ Html/Event»¸ type«data«ReadableStreamReaderMode¸ |«_ReadableStreamReaderMode:byob«"byob"»»»¸ data«ReadableStreamType¸ |«_ReadableStreamType:bytes«"bytes"»»»¸ alias«ReadableStreamGetReaderOptions«.rest»¸ {«mode«ReadableStreamReaderMode»¸ .rest»»¸ alias«ReadableStreamIteratorOptions«.rest»¸ {«preventCancel«Bool»¸ .rest»»¸ alias«ReadableWritablePair«.rest»¸ {«readable«ReadableStream»¸ writable«WritableStream»¸ .rest»»¸ alias«StreamPipeOptions«.rest»¸ {«preventClose«Bool»¸ preventAbort«Bool»¸ preventCancel«Bool»¸ signal«AbortSignal»¸ .rest»»¸ alias«UnderlyingSourceStartCallback¸ ->«ReadableStreamController¸ Unit»»¸ alias«UnderlyingSourcePullCallback¸ ->«ReadableStreamController¸ Promise«Unit»»»¸ alias«UnderlyingSourceCancelCallback«any»¸ ->«?«any»¸ Promise«Unit»»»¸ alias«UnderlyingSource«any¸ .rest»¸ {«start«UnderlyingSourceStartCallback»¸ pull«UnderlyingSourcePullCallback»¸ cancel«UnderlyingSourceCancelCallback«any»»¸ type«ReadableStreamType»¸ autoAllocateChunkSize«Number»¸ .rest»»¸ alias«ReadableStreamReadResult«any¸ .rest»¸ {«value«any»¸ done«Bool»¸ .rest»»¸ alias«ReadableStreamBYOBReaderReadOptions«.rest»¸ {«min«Number»¸ .rest»»¸ alias«UnderlyingSinkStartCallback¸ ->«WritableStreamDefaultController¸ Unit»»¸ alias«UnderlyingSinkWriteCallback«any»¸ ->«any¸ WritableStreamDefaultController¸ Promise«Unit»»»¸ alias«UnderlyingSinkCloseCallback¸ ->«Unit¸ Promise«Unit»»»¸ alias«UnderlyingSinkAbortCallback«any»¸ ->«any¸ Promise«Unit»»»¸ alias«UnderlyingSink«any¸ .rest»¸ {«start«UnderlyingSinkStartCallback»¸ write«UnderlyingSinkWriteCallback«any»»¸ close«UnderlyingSinkCloseCallback»¸ abort«UnderlyingSinkAbortCallback«any»»¸ type«any»¸ .rest»»¸ alias«TransformerStartCallback¸ ->«TransformStreamDefaultController¸ Unit»»¸ alias«TransformerTransformCallback¸ ->«TransformStreamDefaultController¸ Promise«Unit»»»¸ alias«TransformerFlushCallback«any»¸ ->«any¸ TransformStreamDefaultController¸ Promise«Unit»»»¸ alias«TransformerCancelCallback«any»¸ ->«any¸ Promise«Unit»»»¸ alias«Transformer«any¸ .rest»¸ {«start«TransformerStartCallback»¸ transform«TransformerTransformCallback»¸ flush«TransformerFlushCallback«any»»¸ cancel«TransformerCancelCallback«any»»¸ readableType«any»¸ writableType«any»¸ .rest»»¸ alias«QueuingStrategySize«any»¸ ->«any¸ Number»»¸ alias«QueuingStrategy«any¸ .rest»¸ {«highWaterMark«Number»¸ size«QueuingStrategySize«any»»¸ .rest»»¸ alias«QueuingStrategyInit«.rest»¸ {«highWaterMark«Number»¸ .rest»»¸ "## ReadableStream

The ReadableStream interface of the Streams API represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.

ReadableStream is a transferable object."¸ object«ReadableStream¸ new«->«object¸ ?«QueuingStrategy«any¸ |»»¸ ReadableStream»»¸ from«->«any¸ ReadableStream»»¸ locked«Bool¸ get»¸ cancel«->«?«any»¸ Unit»»¸ getReader«->«?«ReadableStreamGetReaderOptions«|»»¸ ReadableStreamReader»»¸ pipeThrough«->«ReadableWritablePair«|»¸ ?«StreamPipeOptions«|»»¸ ReadableStream»»¸ pipeTo«->«WritableStream¸ ?«StreamPipeOptions«|»»¸ Unit»»¸ tee«ReadableStream»»¸ "## ReadableStreamDefaultReader

The ReadableStreamDefaultReader interface of the Streams API represents a default reader that can be used to read stream data supplied from a network (such as a fetch request).

A ReadableStreamDefaultReader can be used to read from a ReadableStream that has an underlying source of any type (unlike a ReadableStreamBYOBReader, which can only be used with readable streams that have an underlying byte source).

Note however that zero-copy transfer from an underlying source is only supported for underlying byte sources that autoallocate buffers. In other words, the stream must have been constructed specifying both `type=""bytes""` and autoAllocateChunkSize. For any other underlying source, the stream will always satisfy read requests with data from internal queues."¸ object«ReadableStreamReader¸ closed«Unit¸ get»¸ cancel«->«?«any»¸ Unit»»¸ releaseLock«Unit»»¸ object«ReadableStreamDefaultReader¸ extends«ReadableStreamReader»¸ new«->«ReadableStream¸ ReadableStreamDefaultReader»»¸ read«ReadableStreamReadResult«any¸ |»»»¸ "## ReadableStreamBYOBReader

The ReadableStreamBYOBReader interface of the Streams API defines a reader for a ReadableStream that supports zero-copy reading from an underlying byte source. It is used for efficient copying from underlying sources where the data is delivered as an ""anonymous"" sequence of bytes, such as files.

An instance of this reader type should usually be obtained by calling `ReadableStream.getReader()` on the stream, specifying `mode: ""byob""` in the options parameter. The readable stream must have an underlying byte source. In other words, it must have been constructed specifying an underlying source with `type: ""bytes""`).

Using this kind of reader, a `read()` request when the readable stream's internal queues are empty will result in a zero copy transfer from the underlying source (bypassing the stream's internal queues). If the internal queues are not empty, a `read()` will satisfy the request from the buffered data.

Note that the methods and properties are similar to those for the default reader (ReadableStreamDefaultReader). The `read()` method differs in that it provides a view into which data should be written."¸ object«ReadableStreamBYOBReader¸ extends«ReadableStreamReader»¸ new«->«ReadableStream¸ ReadableStreamBYOBReader»»¸ read«->«ArrayBuffer¸ ?«ReadableStreamBYOBReaderReadOptions«|»»¸ ReadableStreamReadResult«any¸ |»»»»¸ "## ReadableStreamDefaultController

The ReadableStreamDefaultController interface of the Streams API represents a controller allowing control of a ReadableStream's state and internal queue. Default controllers are for streams that are not byte streams."¸ object«ReadableStreamController¸ desiredSize«?«Number»¸ get»¸ close«Unit»¸ error«->«?«any»¸ Unit»»»¸ object«ReadableStreamDefaultController¸ extends«ReadableStreamController»¸ enqueue«->«?«any»¸ Unit»»»¸ "## ReadableByteStreamController


The ReadableByteStreamController interface of the Streams API represents a controller for a readable byte stream. It allows control of the state and internal queue of a ReadableStream with an underlying byte source, and enables efficient zero-copy transfer of data from the underlying source to a consumer when the stream's internal queue is empty."¸ object«ReadableByteStreamController¸ extends«ReadableStreamController»¸ byobRequest«?«ReadableStreamBYOBRequest»¸ get»¸ enqueue«->«ArrayBuffer¸ Unit»»»¸ "## ReadableStreamBYOBRequest


The ReadableStreamBYOBRequest interface of the Streams API represents a ""pull request"" for data from an underlying source that will made as a zero-copy transfer to a consumer (bypassing the stream's internal queues)."¸ object«ReadableStreamBYOBRequest¸ view«?«ArrayBuffer»¸ get»¸ respond«->«Number¸ Unit»»¸ respondWithNewView«->«ArrayBuffer¸ Unit»»»¸ "## WritableStream


The WritableStream interface of the Streams API provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing."¸ object«WritableStream¸ new«->«object¸ ?«QueuingStrategy«any¸ |»»¸ WritableStream»»¸ locked«Bool¸ get»¸ abort«->«?«any»¸ Unit»»¸ close«Unit»¸ getWriter«WritableStreamDefaultWriter»»¸ "## WritableStreamDefaultWriter


The WritableStreamDefaultWriter interface of the Streams API is the object returned by `WritableStream.getWriter()` and once created locks the writer to the WritableStream ensuring that no other streams can write to the underlying sink."¸ object«WritableStreamDefaultWriter¸ new«->«WritableStream¸ WritableStreamDefaultWriter»»¸ closed«Unit¸ get»¸ desiredSize«?«Number»¸ get»¸ ready«Unit¸ get»¸ abort«->«?«any»¸ Unit»»¸ close«Unit»¸ releaseLock«Unit»¸ write«->«?«any»¸ Unit»»»¸ "## WritableStreamDefaultController

The WritableStreamDefaultController interface of the Streams API represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate."¸ object«WritableStreamDefaultController¸ signal«AbortSignal¸ get»¸ error«->«?«any»¸ Unit»»»¸ "## TransformStream

The TransformStream interface of the Streams API represents a concrete implementation of the pipe chain transform stream concept.

It may be passed to the 
`ReadableStream.pipeThrough()` method in order to transform a stream of data from one format into another. For example, it might be used to decode (or encode) video frames, decompress data, or convert the stream from XML to JSON."¸ object«TransformStream¸ new«->«object¸ ?«QueuingStrategy«any¸ |»»¸ ?«QueuingStrategy«any¸ |»»¸ TransformStream»»¸ readable«ReadableStream¸ get»¸ writable«WritableStream¸ get»»¸ "## TransformStreamDefaultController

The TransformStreamDefaultController interface of the Streams API provides methods to manipulate the associated ReadableStream and WritableStream."¸ object«TransformStreamDefaultController¸ desiredSize«?«Number»¸ get»¸ enqueue«->«?«any»¸ Unit»»¸ error«->«?«any»¸ Unit»»¸ terminate«Unit»»¸ "## ByteLengthQueuingStrategy

The ByteLengthQueuingStrategy interface of the Streams API provides a built-in byte length queuing strategy that can be used when constructing streams."¸ object«ByteLengthQueuingStrategy¸ new«->«QueuingStrategyInit«|»¸ ByteLengthQueuingStrategy»»¸ highWaterMark«Number¸ get»¸ size«Function«any»¸ get»»¸ "## CountQueuingStrategy


The CountQueuingStrategy interface of the Streams API provides a built-in chunk counting queuing strategy that can be used when constructing streams."¸ object«CountQueuingStrategy¸ new«->«QueuingStrategyInit«|»¸ CountQueuingStrategy»»¸ highWaterMark«Number¸ get»¸ size«Function«any»¸ get»»»»